name: CA certs tests
on:
  workflow_dispatch:
  push:
    branches: [pull/5429]
  pull_request:
    branches: [main]

jobs:
  cli_tests_linux:
    name: cli tests for linux
    runs-on: ubuntu-latest
    permissions:
      checks: write
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: v22.17.0

      - name: install os dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libxml2-utils lsof

      - name: setup CA certificates
        run: |
          set -euo pipefail

          cd e2e-tests/ca_certs/server

          echo "running certificate setup"
          node setup.js

      - name: start test server
        run: |
          set -euo pipefail

          cd e2e-tests/ca_certs/server

          echo "starting server in background"
          node index.js &

          echo "server started with PID: $!"

          # wait for server to be ready
          sleep 5

          # verify server is running
          if curl -k https://localhost:8090; then
            echo "server is responding"
          else
            echo "server is not responding"
            exit 1
          fi

      - name: install node dependencies
        run: npm ci --legacy-peer-deps

      - name: build libraries
        run: |
          npm run build --workspace=packages/bruno-query
          npm run build --workspace=packages/bruno-common
          npm run sandbox:bundle-libraries --workspace=packages/bruno-js
          npm run build --workspace=packages/bruno-converters
          npm run build --workspace=packages/bruno-requests
          npm run build --workspace=packages/bruno-filestore

      - name: run cli tests
        run: |
          set -euo pipefail

          # navigate to CA certificates test collection directory
          cd e2e-tests/ca_certs/collection

          echo "with ssl/tls disabled"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit1.xml --insecure --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit1.xml | grep -q "^1$" || exit 1

          echo "with default/sytem ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit2.xml --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit2.xml | grep -q "^1$" || exit 1

          echo "with only VALID custom ca cert and NO default/system ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit3.xml --cacert ../server/certs/ca-cert.pem --ignore-truststore --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit3.xml | grep -q "^1$" || exit 1

          echo "with INVALID custom ca cert and default/system ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit4.xml --cacert ../server/certs/ca-cert.key --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit4.xml | grep -q "^1$" || exit 1

          echo "with INVALID custom ca cert and NO default/system ca certs"
          echo "request will error but the pre-request test should pass"
          # should fail
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit5.xml --cacert ../server/certs/ca-key.pem --ignore-truststore --format junit 2>/dev/null || true
          xmllint --xpath 'count(//testsuite[@errors="1"])' junit5.xml | grep -q "^1$" || exit 1

  e2e_tests_linux:
    name: e2e tests for linux
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: v22.17.0

    - name: install os dependencies
      run: |
        sudo apt-get update
        sudo apt-get --no-install-recommends install -y \
          libglib2.0-0 libnss3 libdbus-1-3 libatk1.0-0 libatk-bridge2.0-0 libcups2 libgtk-3-0 libasound2t64 \
          xvfb lsof
        npm ci --legacy-peer-deps
        sudo chown root /home/runner/work/bruno/bruno/node_modules/electron/dist/chrome-sandbox
        sudo chmod 4755 /home/runner/work/bruno/bruno/node_modules/electron/dist/chrome-sandbox

    - name: setup CA certificates
      run: |
        set -euo pipefail

        cd e2e-tests/ca_certs/server

        echo "running certificate setup"
        node setup.js

    - name: start test server
      run: |
        set -euo pipefail

        cd e2e-tests/ca_certs/server

        echo "starting server in background"
        node index.js &

        echo "server started with PID: $!"

        # wait for server to be ready
        sleep 5

        # verify server is running
        if curl -k https://localhost:8090; then
          echo "server is responding"
        else
          echo "server is not responding"
          exit 1
        fi

    - name: install node dependencies
      run: npm ci --legacy-peer-deps

    - name: build libraries
      run: |
        npm run build:graphql-docs
        npm run build:bruno-query
        npm run build:bruno-common
        npm run sandbox:bundle-libraries --workspace=packages/bruno-js
        npm run build:bruno-converters
        npm run build:bruno-requests
        npm run build:bruno-filestore

    - name: run e2e tests
      run: |
        xvfb-run npm run test:e2e:ca_certs

    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        name: playwright-report-linux
        path: playwright-report/
        retention-days: 30

  cli_tests_macos:
    name: cli tests for macos
    runs-on: macos-latest
    permissions:
      checks: write
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: v22.17.0

      - name: install os dependencies
        run: brew install libxml2

      - name: setup CA certificates
        run: |
          set -euo pipefail

          cd e2e-tests/ca_certs/server

          echo "running certificate setup"
          node setup.js

      - name: start test server
        run: |
          set -euo pipefail

          cd e2e-tests/ca_certs/server

          echo "starting server in background"
          node index.js &

          echo "server started with PID: $!"

          # wait for server to be ready
          sleep 5

          # verify server is running
          if curl -k https://localhost:8090; then
            echo "server is responding"
          else
            echo "server is not responding"
            exit 1
          fi

      - name: install node dependencies
        run: npm ci --legacy-peer-deps

      - name: build libraries
        run: |
          npm run build --workspace=packages/bruno-query
          npm run build --workspace=packages/bruno-common
          npm run sandbox:bundle-libraries --workspace=packages/bruno-js
          npm run build --workspace=packages/bruno-converters
          npm run build --workspace=packages/bruno-requests
          npm run build --workspace=packages/bruno-filestore

      - name: run cli tests
        run: |
          set -euo pipefail

          # navigate to CA certificates test collection directory
          cd e2e-tests/ca_certs/collection

          echo "with ssl/tls disabled"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit1.xml --insecure --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit1.xml | grep -q "^1$" || exit 1

          echo "with default/sytem ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit2.xml --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit2.xml | grep -q "^1$" || exit 1

          echo "with only VALID custom ca cert and NO default/system ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit3.xml --cacert ../server/certs/ca-cert.pem --ignore-truststore --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit3.xml | grep -q "^1$" || exit 1

          echo "with INVALID custom ca cert and default/system ca certs"
          # should pass
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit4.xml --cacert ../server/certs/ca-cert.key --format junit
          xmllint --xpath 'count(//testsuite[@errors="0"])' junit4.xml | grep -q "^1$" || exit 1

          echo "with INVALID custom ca cert and NO default/system ca certs"
          echo "request will error but the pre-request test should pass"
          # should fail
          node ../../../packages/bruno-cli/bin/bru.js run ./request.bru --output junit5.xml --cacert ../server/certs/ca-key.pem --ignore-truststore --format junit 2>/dev/null || true
          xmllint --xpath 'count(//testsuite[@errors="1"])' junit5.xml | grep -q "^1$" || exit 1

  e2e_tests_macos:
    name: e2e tests for macos
    timeout-minutes: 60
    runs-on: macos-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: v22.17.0

    - name: setup CA certificates
      run: |
        set -euo pipefail

        cd e2e-tests/ca_certs/server

        echo "running certificate setup"
        node setup.js

    - name: start test server
      run: |
        set -euo pipefail

        cd e2e-tests/ca_certs/server

        echo "starting server in background"
        node index.js &

        echo "server started with PID: $!"

        # wait for server to be ready
        sleep 5

        # verify server is running
        if curl -k https://localhost:8090; then
          echo "server is responding"
        else
          echo "server is not responding"
          exit 1
        fi

    - name: install node dependencies
      run: npm ci --legacy-peer-deps

    - name: build libraries
      run: |
        npm run build:graphql-docs
        npm run build:bruno-query
        npm run build:bruno-common
        npm run sandbox:bundle-libraries --workspace=packages/bruno-js
        npm run build:bruno-converters
        npm run build:bruno-requests
        npm run build:bruno-filestore

    - name: run e2e tests
      run: |
        set -euo pipefail

        npm run test:e2e:ca_certs

    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        name: playwright-report-macos
        path: playwright-report/
        retention-days: 30

  cli_tests_windows:
    name: cli tests for windows
    runs-on: windows-latest
    permissions:
      checks: write
      pull-requests: write
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: v22.17.0

      - name: setup CA certificates
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          Set-Location e2e-tests\ca_certs\server

          Write-Host "running certificate setup"
          node setup.js

      - name: start test server
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          # Configure SSL to accept self-signed certificates BEFORE any network operations
          Write-Host "Configuring SSL settings for self-signed certificates"
          [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
          [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 -bor [System.Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls
          Write-Host "SSL configuration completed"

          Write-Host "Changing to server directory"
          Set-Location e2e-tests\ca_certs\server
          Write-Host "Current working directory: $(Get-Location)"

          Write-Host "current directory: $(Get-Location)"
          Write-Host "checking certificate files before starting server"
          $certFiles = @('certs\ca-cert.pem', 'certs\ca-key.pem', 'certs\localhost-cert.pem', 'certs\localhost-key.pem')
          foreach ($certFile in $certFiles) {
            if (Test-Path $certFile) {
              Write-Host "[OK] $certFile exists"
            } else {
              Write-Host "[MISSING] $certFile missing - server will likely fail"
            }
          }

          Write-Host "checking if port 8090 is already in use"
          try {
            $netstatResult = netstat -ano | findstr :8090
            if ($netstatResult) {
              Write-Host "Port 8090 is already in use:"
              Write-Host $netstatResult
            } else {
              Write-Host "Port 8090 is available"
            }
          } catch {
            Write-Host "Could not check port status"
          }

          Write-Host "starting server in background"
          # Using Start-Process with output redirection to capture logs
          try {
            $process = Start-Process -FilePath "node" -ArgumentList "index.js" -PassThru -RedirectStandardOutput "server.log" -RedirectStandardError "server.error" -NoNewWindow
            Write-Host "server started with Process ID: $($process.Id)"
            Write-Host "Process handle: $($process.Handle)"
            Write-Host "Process has exited: $($process.HasExited)"
          } catch {
            Write-Host "ERROR: Failed to start server process"
            Write-Host "Error details: $($_.Exception.Message)"
            Write-Host "Error type: $($_.Exception.GetType().FullName)"
            exit 1
          }

          # Give server a moment to start and check if it's still running
          Write-Host "Waiting 1 second for server to initialize..."
          Start-Sleep -Seconds 1
          Write-Host "Checking if server process is still running..."
          if ($process.HasExited) {
            Write-Host "ERROR: Server process exited immediately with code: $($process.ExitCode)"
            Write-Host "Process start time: $($process.StartTime)"
            Write-Host "Process exit time: $($process.ExitTime)"
            Write-Host "Process total processor time: $($process.TotalProcessorTime)"
          } else {
            Write-Host "SUCCESS: Server process is still running"
            Write-Host "Process start time: $($process.StartTime)"
            Write-Host "Process working set: $($process.WorkingSet) bytes"
          }

          # wait for server to be ready with retry logic
          $MaxWaitTime = 30
          $WaitInterval = 2
          $ElapsedTime = 0

          Write-Host "waiting for server to be ready (max $MaxWaitTime seconds)..."
          while ($ElapsedTime -lt $MaxWaitTime) {

            # Check if process has exited
            if ($process.HasExited) {
              Write-Host "Server process has exited with code: $($process.ExitCode)"
              # Show server logs
              if (Test-Path "server.log") {
                $logs = Get-Content "server.log" -ErrorAction SilentlyContinue
                if ($logs) {
                  Write-Host "Server stdout logs:"
                  foreach ($line in $logs) {
                    Write-Host "  $line"
                  }
                }
              }
              if (Test-Path "server.error") {
                $errorLogs = Get-Content "server.error" -ErrorAction SilentlyContinue
                if ($errorLogs) {
                  Write-Host "Server stderr logs:"
                  foreach ($line in $errorLogs) {
                    Write-Host "  $line"
                  }
                }
              }
              exit 1
            }

            # Show recent server logs
            if (Test-Path "server.log") {
              $logs = Get-Content "server.log" -Tail 3 -ErrorAction SilentlyContinue
              if ($logs) {
                $recentLogs = $logs -join '; '
                Write-Host "Recent server logs: $recentLogs"
              }
            }

            try {
              Write-Host "Attempting to connect to server (attempt $($ElapsedTime/$WaitInterval + 1))..."
              # Use Invoke-WebRequest with SSL bypass for self-signed certificates
              $response = Invoke-WebRequest -Uri "https://localhost:8090" -SkipCertificateCheck -TimeoutSec 3 -UseBasicParsing
              Write-Host "SUCCESS: server is responding after $ElapsedTime seconds"
              Write-Host "Response status code: $($response.StatusCode)"
              Write-Host "Response content length: $($response.Content.Length)"
              break
            } catch {
              Write-Host "server not ready yet, waiting $WaitInterval seconds... $ElapsedTime/$MaxWaitTime"
              Write-Host "Error details: $($_.Exception.Message)"
              Write-Host "Error type: $($_.Exception.GetType().FullName)"
              if ($_.Exception.InnerException) {
                Write-Host "Inner exception: $($_.Exception.InnerException.Message)"
              }
              Start-Sleep -Seconds $WaitInterval
              $ElapsedTime += $WaitInterval
            }
          }

          # final verification
          Write-Host "Performing final verification of server readiness..."
          try {
            # Use Invoke-WebRequest with SSL bypass for self-signed certificates
            $response = Invoke-WebRequest -Uri "https://localhost:8090" -SkipCertificateCheck -TimeoutSec 3 -UseBasicParsing
            Write-Host "SUCCESS: server is ready and responding"
            Write-Host "Final response status code: $($response.StatusCode)"
            Write-Host "Final response content length: $($response.Content.Length)"
            Write-Host "Server verification completed successfully"

            # Final process status check
            Write-Host "Final process status check..."
            if ($process.HasExited) {
              Write-Host "WARNING: Server process has exited with code: $($process.ExitCode)"
              Write-Host "Process exit time: $($process.ExitTime)"
            } else {
              Write-Host "SUCCESS: Server process is still running and healthy"
              Write-Host "Process uptime: $((Get-Date) - $process.StartTime)"
            }
          } catch {
            Write-Host "ERROR: server failed to start within $MaxWaitTime seconds"
            Write-Host "Final error details: $($_.Exception.Message)"
            Write-Host "Final error type: $($_.Exception.GetType().FullName)"
            if ($_.Exception.InnerException) {
              Write-Host "Final inner exception: $($_.Exception.InnerException.Message)"
            }
            # Show final server logs
            if (Test-Path "server.log") {
              $logs = Get-Content "server.log" -ErrorAction SilentlyContinue
              if ($logs) {
                Write-Host "Final server stdout logs:"
                foreach ($line in $logs) {
                  Write-Host "  $line"
                }
              }
            }
            if (Test-Path "server.error") {
              $errorLogs = Get-Content "server.error" -ErrorAction SilentlyContinue
              if ($errorLogs) {
                Write-Host "Final server stderr logs:"
                foreach ($line in $errorLogs) {
                  Write-Host "  $line"
                }
              }
            }
            Stop-Process $process -Force -ErrorAction SilentlyContinue
            exit 1
          }

      - name: install node dependencies
        run: npm ci --legacy-peer-deps

      - name: build libraries
        run: |
          npm run build --workspace=packages/bruno-query
          npm run build --workspace=packages/bruno-common
          npm run sandbox:bundle-libraries --workspace=packages/bruno-js
          npm run build --workspace=packages/bruno-converters
          npm run build --workspace=packages/bruno-requests
          npm run build --workspace=packages/bruno-filestore

      - name: run cli tests
        shell: pwsh
        run: |
          Set-StrictMode -Version Latest
          $ErrorActionPreference = "Stop"

          # navigate to CA certificates test collection directory
          Set-Location e2e-tests\ca_certs\collection

          Write-Host "with ssl/tls disabled"
          # should pass
          node ..\..\..\packages\bruno-cli\bin\bru.js run .\request.bru --output junit1.xml --insecure --format junit
          [xml]$xml1 = Get-Content junit1.xml
          $testsuites1 = if ($xml1.testsuites) { $xml1.testsuites.testsuite } else { $xml1.testsuite }
          $errorCount1 = ($testsuites1 | Where-Object { $_.errors -eq "0" } | Measure-Object).Count
          Write-Host "Test 1 (insecure): errorCount=$errorCount1, expected=1"
          if ($errorCount1 -ne 1) {
            Write-Host "Test 1 failed - exiting"
            exit 1
          }

          Write-Host "with default/sytem ca certs"
          # should pass
          node ..\..\..\packages\bruno-cli\bin\bru.js run .\request.bru --output junit2.xml --format junit
          [xml]$xml2 = Get-Content junit2.xml
          $testsuites2 = if ($xml2.testsuites) { $xml2.testsuites.testsuite } else { $xml2.testsuite }
          $errorCount2 = ($testsuites2 | Where-Object { $_.errors -eq "0" } | Measure-Object).Count
          Write-Host "Test 2 (system certs): errorCount=$errorCount2, expected=1"
          if ($errorCount2 -ne 1) {
            Write-Host "Test 2 failed - exiting"
            exit 1
          }

          Write-Host "with only VALID custom ca cert and NO default/system ca certs"
          # should pass
          node ..\..\..\packages\bruno-cli\bin\bru.js run .\request.bru --output junit3.xml --cacert ..\server\certs\ca-cert.pem --ignore-truststore --format junit
          [xml]$xml3 = Get-Content junit3.xml
          $testsuites3 = if ($xml3.testsuites) { $xml3.testsuites.testsuite } else { $xml3.testsuite }
          $errorCount3 = ($testsuites3 | Where-Object { $_.errors -eq "0" } | Measure-Object).Count
          Write-Host "Test 3 (custom cert): errorCount=$errorCount3, expected=1"
          if ($errorCount3 -ne 1) {
            Write-Host "Test 3 failed - exiting"
            exit 1
          }

          Write-Host "with INVALID custom ca cert and default/system ca certs"
          # should pass
          node ..\..\..\packages\bruno-cli\bin\bru.js run .\request.bru --output junit4.xml --cacert ..\server\certs\ca-cert.key --format junit
          [xml]$xml4 = Get-Content junit4.xml
          $testsuites4 = if ($xml4.testsuites) { $xml4.testsuites.testsuite } else { $xml4.testsuite }
          $errorCount4 = ($testsuites4 | Where-Object { $_.errors -eq "0" } | Measure-Object).Count
          if ($errorCount4 -ne 1) { exit 1 }

          Write-Host "with INVALID custom ca cert and NO default/system ca certs"
          Write-Host "request will error but the pre-request test should pass"
          # should fail
          try {
            node ..\..\..\packages\bruno-cli\bin\bru.js run .\request.bru --output junit5.xml --cacert ..\server\certs\ca-key.pem --ignore-truststore --format junit 2>$null
          } catch {
            # Expected to fail
          }
          [xml]$xml5 = Get-Content junit5.xml
          $testsuites5 = if ($xml5.testsuites) { $xml5.testsuites.testsuite } else { $xml5.testsuite }
          $errorCount5 = ($testsuites5 | Where-Object { $_.errors -eq "1" } | Measure-Object).Count
          if ($errorCount5 -ne 1) { exit 1 }

  e2e_tests_windows:
    name: e2e tests for windows
    timeout-minutes: 60
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: v22.17.0

    - name: setup CA certificates
      shell: powershell
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = "Stop"

        Set-Location e2e-tests\ca_certs\server

        Write-Host "running certificate setup"
        node setup.js

    - name: start test server
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = "Stop"

        # Configure SSL to accept self-signed certificates BEFORE any network operations
        Write-Host "Configuring SSL settings for self-signed certificates"
        [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12 -bor [System.Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls
        Write-Host "SSL configuration completed"

        Write-Host "Changing to server directory"
        Set-Location e2e-tests\ca_certs\server
        Write-Host "Current working directory: $(Get-Location)"

        Write-Host "current directory: $(Get-Location)"
        Write-Host "checking certificate files before starting server"
        $certFiles = @('certs\ca-cert.pem', 'certs\ca-key.pem', 'certs\localhost-cert.pem', 'certs\localhost-key.pem')
        foreach ($certFile in $certFiles) {
          if (Test-Path $certFile) {
            Write-Host "[OK] $certFile exists"
          } else {
            Write-Host "[MISSING] $certFile missing - server will likely fail"
          }
        }

        Write-Host "checking if port 8090 is already in use"
        try {
          $netstatResult = netstat -ano | findstr :8090
          if ($netstatResult) {
            Write-Host "Port 8090 is already in use:"
            Write-Host $netstatResult
          } else {
            Write-Host "Port 8090 is available"
          }
        } catch {
          Write-Host "Could not check port status"
        }

        Write-Host "starting server in background"
        # Using Start-Process with output redirection to capture logs
        try {
          $process = Start-Process -FilePath "node" -ArgumentList "index.js" -PassThru -RedirectStandardOutput "server.log" -RedirectStandardError "server.error" -NoNewWindow
          Write-Host "server started with Process ID: $($process.Id)"
          Write-Host "Process handle: $($process.Handle)"
          Write-Host "Process has exited: $($process.HasExited)"
        } catch {
          Write-Host "ERROR: Failed to start server process"
          Write-Host "Error details: $($_.Exception.Message)"
          Write-Host "Error type: $($_.Exception.GetType().FullName)"
          exit 1
        }

        # Give server a moment to start and check if it's still running
        Write-Host "Waiting 1 second for server to initialize..."
        Start-Sleep -Seconds 1
        Write-Host "Checking if server process is still running..."
        if ($process.HasExited) {
          Write-Host "ERROR: Server process exited immediately with code: $($process.ExitCode)"
          Write-Host "Process start time: $($process.StartTime)"
          Write-Host "Process exit time: $($process.ExitTime)"
          Write-Host "Process total processor time: $($process.TotalProcessorTime)"
        } else {
          Write-Host "SUCCESS: Server process is still running"
          Write-Host "Process start time: $($process.StartTime)"
          Write-Host "Process working set: $($process.WorkingSet) bytes"
        }

        # wait for server to be ready with retry logic
        $MaxWaitTime = 30
        $WaitInterval = 2
        $ElapsedTime = 0

        Write-Host "waiting for server to be ready (max $MaxWaitTime seconds)..."
        while ($ElapsedTime -lt $MaxWaitTime) {

          # Check if process has exited
          if ($process.HasExited) {
            Write-Host "Server process has exited with code: $($process.ExitCode)"
            # Show server logs
            if (Test-Path "server.log") {
              $logs = Get-Content "server.log" -ErrorAction SilentlyContinue
              if ($logs) {
                Write-Host "Server stdout logs:"
                foreach ($line in $logs) {
                  Write-Host "  $line"
                }
              }
            }
            if (Test-Path "server.error") {
              $errorLogs = Get-Content "server.error" -ErrorAction SilentlyContinue
              if ($errorLogs) {
                Write-Host "Server stderr logs:"
                foreach ($line in $errorLogs) {
                  Write-Host "  $line"
                }
              }
            }
            exit 1
          }

          # Show recent server logs
          if (Test-Path "server.log") {
            $logs = Get-Content "server.log" -Tail 3 -ErrorAction SilentlyContinue
            if ($logs) {
              $recentLogs = $logs -join '; '
              Write-Host "Recent server logs: $recentLogs"
            }
          }

          try {
            Write-Host "Attempting to connect to server (attempt $($ElapsedTime/$WaitInterval + 1))..."
            # Use Invoke-WebRequest with SSL bypass for self-signed certificates
            $response = Invoke-WebRequest -Uri "https://localhost:8090" -SkipCertificateCheck -TimeoutSec 3 -UseBasicParsing
            Write-Host "SUCCESS: server is responding after $ElapsedTime seconds"
            Write-Host "Response status code: $($response.StatusCode)"
            Write-Host "Response content length: $($response.Content.Length)"
            break
          } catch {
            Write-Host "server not ready yet, waiting $WaitInterval seconds... $ElapsedTime/$MaxWaitTime"
            Write-Host "Error details: $($_.Exception.Message)"
            Write-Host "Error type: $($_.Exception.GetType().FullName)"
            if ($_.Exception.InnerException) {
              Write-Host "Inner exception: $($_.Exception.InnerException.Message)"
            }
            Start-Sleep -Seconds $WaitInterval
            $ElapsedTime += $WaitInterval
          }
        }

        # final verification
        Write-Host "Performing final verification of server readiness..."
        try {
          # Use Invoke-WebRequest with SSL bypass for self-signed certificates
          $response = Invoke-WebRequest -Uri "https://localhost:8090" -SkipCertificateCheck -TimeoutSec 3 -UseBasicParsing
          Write-Host "SUCCESS: server is ready and responding"
          Write-Host "Final response status code: $($response.StatusCode)"
          Write-Host "Final response content length: $($response.Content.Length)"
                      Write-Host "Server verification completed successfully"

            # Final process status check
            Write-Host "Final process status check..."
            if ($process.HasExited) {
              Write-Host "WARNING: Server process has exited with code: $($process.ExitCode)"
              Write-Host "Process exit time: $($process.ExitTime)"
            } else {
              Write-Host "SUCCESS: Server process is still running and healthy"
              Write-Host "Process uptime: $((Get-Date) - $process.StartTime)"
            }
        } catch {
          Write-Host "ERROR: server failed to start within $MaxWaitTime seconds"
          Write-Host "Final error details: $($_.Exception.Message)"
          Write-Host "Final error type: $($_.Exception.GetType().FullName)"
          if ($_.Exception.InnerException) {
            Write-Host "Final inner exception: $($_.Exception.InnerException.Message)"
          }
          # Show final server logs
          if (Test-Path "server.log") {
            $logs = Get-Content "server.log" -ErrorAction SilentlyContinue
            if ($logs) {
              Write-Host "Final server stdout logs:"
              foreach ($line in $logs) {
                Write-Host "  $line"
              }
            }
          }
          if (Test-Path "server.error") {
            $errorLogs = Get-Content "server.error" -ErrorAction SilentlyContinue
            if ($errorLogs) {
              Write-Host "Final server stderr logs:"
              foreach ($line in $errorLogs) {
                Write-Host "  $line"
              }
            }
          }
          Stop-Process $process -Force -ErrorAction SilentlyContinue
          exit 1
        }

    - name: install node dependencies
      run: npm ci --legacy-peer-deps

    - name: build libraries
      run: |
        npm run build:graphql-docs
        npm run build:bruno-query
        npm run build:bruno-common
        npm run sandbox:bundle-libraries --workspace=packages/bruno-js
        npm run build:bruno-converters
        npm run build:bruno-requests
        npm run build:bruno-filestore

    - name: run e2e tests
      run: npm run test:e2e:ca_certs

    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        name: playwright-report-windows
        path: playwright-report/
        retention-days: 30
